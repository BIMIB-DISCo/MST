##############################################################################
###
### MST
###
### Reconstruction (pf run)
###
##############################################################################
### Copyright (c) 2015-2018, The TRONCO Team (www.troncopackage.org)
### email: tronco@disco.unimib.it
### All rights reserved. This program and the accompanying materials
### are made available under the terms of the GNU GPL v3.0
### which accompanies this distribution
##############################################################################


## Perform the reconstructions

run.reconstructions <- function(dataset, true_tree) {
    
    results = NULL
    
    ## Create a TRONCO object of the dataset
    data = import.genotypes(dataset)
    
   
    ## Performs the reconstructions with Edmonds no_reg, loglik, aic and bic
    res = NULL
    
    ## res = tronco.mst.edmonds(data, regularization = c("no_reg", "loglik", "aic", "bic"))
    res = tronco.mst.edmonds(data, regularization = c("no_reg"), silent = TRUE)
    adj.matrix.edmonds.no.reg = as.adj.matrix(res, model = "edmonds_no_reg")
    results.edmonds.no.reg = getStats(true_tree, adj.matrix.edmonds.no.reg[["edmonds_no_reg"]])  
    
    adj.matrix.edmonds.pf.pre = res$adj.matrix.cyclic
    results.edmonds.pf.pre = getStats(true_tree, adj.matrix.edmonds.pf.pre)

    adj.matrix.edmonds.pf.post = res$adj.matrix.prima.facie
    results.edmonds.pf.post = getStats(true_tree, adj.matrix.edmonds.pf.post)


    edmonds = list(model = res,
                   no.reg.adj = adj.matrix.edmonds.no.reg,
                   no.reg.res = results.edmonds.no.reg,
                   pf.pre.adj = adj.matrix.edmonds.pf.pre,
                   pf.pre.res = results.edmonds.pf.pre,
                   pf.post.adj = adj.matrix.edmonds.pf.post,
                   pf.post.res = results.edmonds.pf.post)
    results[["edmonds"]] = edmonds
        
    return(results)
}


## function to compute the results at each step

getStats <- function(true_matrix, inferred_matrix) {
    
    ## print(true_matrix)
    ## print(inferred_matrix)

    ## compute the statistics
    tp = 0
    tn = 0
    fp = 0
    fn = 0
    for (i in 1:nrow(inferred_matrix)) {
        for (j in i:ncol(inferred_matrix)) {
            if (i != j) {
                if (true_matrix[i, j] == 0 && inferred_matrix[i, j] == 0) {
                    tn = tn + 1
                } else if (true_matrix[i, j] == 0 && inferred_matrix[i, j] == 1) {
                    fp = fp + 1
                } else if (true_matrix[i, j] == 1 && inferred_matrix[i, j] == 0) {
                    fn = fn + 1
                } else if (true_matrix[i, j] == 1 && inferred_matrix[i, j] == 1) {
                    tp = tp + 1
                }
            }
        }
    }
    
    ## compute the statistics
    accuracy = (tp + tn) / (tp + tn + fp + fn)
    sensitivity = (tp) / (tp + fn)
    specificity = (tn) / (fp + tn)
    hamming_distance = fp + fn
    
    ## print(accuray)
    ## print(sensitivity)
    ## print(specificity)
    
    ## check for NAs generated by 0/0 computations
    ## this can happen for sensitivity or specificity
    if (is.na(sensitivity)) {
    	sensitivity = 0
    }
    if (is.na(specificity)) {
    	specificity = 0
    }

    ## return the results
    results_values = list(accuracy = accuracy,
                          sensitivity = sensitivity,
                          specificity = specificity,
                          hamming_distance = hamming_distance,
                          tp = tp,
                          tn = tn,
                          fp = fp,
                          fn = fn)
    return(results_values)  
}


expand.input <- function(datasets, true_tree, seed, cores) {
    cat('Using', cores, 'cores via "parallel" \n')
    cl = makeCluster(cores, outfile = '')
    clusterEvalQ(cl, library(TRONCO))
    clusterExport(cl, 'run.reconstructions')
    clusterExport(cl, 'getStats')
    clusterSetRNGStream(cl, iseed = seed)

    for(i in 1:nrow(datasets)) {
        for (j in 1:ncol(datasets)) {
            cat((((i - 1) * ncol(datasets)) + j) , '/', nrow(datasets) * ncol(datasets), '\n')
            single.experiment = datasets[[i, j]]       
            results = parLapply(cl,
                                single.experiment,
                                function(x, true_tree) {
                                    run.reconstructions(x$dataset, true_tree)
                                },
                                true_tree)

            for (k in 1:length(results)) {
                datasets[[i, j]][[k]]$reconstructions = results[[k]]
            }
        }
    }
    stopCluster(cl)
    return(datasets)
}


expand.random.input <- function(datasets, seed, cores) {
    cat('Using', cores, 'cores via "parallel" \n')
    cl = makeCluster(cores)
    clusterEvalQ(cl, library(TRONCO))
    clusterExport(cl, 'run.reconstructions')
    clusterExport(cl, 'getStats')
    clusterSetRNGStream(cl, iseed = seed)

    for(i in 1:nrow(datasets)) {
        for (j in 1:ncol(datasets)) {
            cat((((i - 1) * ncol(datasets)) + j) , '/', nrow(datasets) * ncol(datasets), '\n')
            single.experiment = datasets[[i, j]]       
            results = parLapply(cl,
                                single.experiment,
                                function(x) {
                                    run.reconstructions(x$dataset, x$true_tree$structure)
                                })
            
            for (k in 1:length(results)) {
                datasets[[i, j]][[k]]$reconstructions = results[[k]]
            }
        }
    }
    stopCluster(cl)
    return(datasets)
}


single.test <- function(datasets) {
    sample_level = 5
    noise_level = 5

    datasets = datasets[sample_level, , drop = FALSE]
    results = NULL

    for(i in 1:ncol(datasets)) {
        print(i)
        single.experiment = datasets[[1, i]][[noise_level]]
        results[[i]] = run.reconstructions(single.experiment$dataset, single.experiment$true_tree$structure)
    }
    
    for (i in 1:length(results)) {
        recon = results[[i]]
        pre = recon$edmonds$pf.pre.res
        post = recon$edmonds$pf.post.res
        if (pre$tp != post$tp
            || pre$tn != post$tn
            || pre$fp != post$fp
            || pre$fn != post$fn) {
            cat('results\n')
            cat('pre:  tp', pre$tp, ' tn ', pre$tn, ' fp ', pre$fp, 'fn', pre$fn, '\n')
            cat('post:  tp', post$tp, ' tn ', post$tn, ' fp ', post$fp, 'fn', post$fn, '\n')
            cat('pre matrix\n')
            print(recon$edmonds$model$adj.matrix.cyclic)
            cat('post matrix\n')
            print(recon$edmonds$model$adj.matrix.prima.facie)
            cat('marginal probs\n')
            print(recon$edmonds$model$model$edmonds_no_reg$probabilities$probabilities.observed$marginal.probs)
            cat('joint probs\n')
            print(recon$edmonds$model$model$edmonds_no_reg$probabilities$probabilities.observed$joint.probs)
            cat('conditional probs\n')
            print(recon$edmonds$model$model$edmonds_no_reg$probabilities$probabilities.observed$conditional.probs)
            cat('\n')
        }
    }

    return(results)
}

### end of file -- reconstruct.test.pf.run.R
